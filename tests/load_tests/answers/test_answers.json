{
    "p006": {
        "AC": "s = input().strip()\nnumRows = int(input())\n\nif numRows == 1:\n    print(s)\n    exit()\n\nrows = [[] for _ in range(numRows)]\ndirection = -1\ncurrent_row = 0\n\nfor char in s:\n    rows[current_row].append(char)\n    if current_row == 0 or current_row == numRows - 1:\n        direction *= -1\n    current_row += direction\n\nresult = []\nfor row in rows:\n    result.extend(row)\nprint(''.join(result))",
        "WA": "s = input().strip()\nnumRows = int(input())\n\nif numRows == 1:\n    print(s)\n    exit()\n\nrows = [[] for _ in range(numRows)]\ndirection = -1\ncurrent_row = 0\n\nfor char in s:\n    rows[current_row].append(char)\n    if current_row == 0 or current_row == numRows - 1:\n        direction *= -1\n    current_row += direction\n\nresult = []\nfor row in rows:\n    result.extend(row)\nprint(''.join(result))\nprint('wrong answer')\n",
        "RE": "s = input().strip()\nnumRows = int(input())\n\nif numRows == 1:\n    print(s)\n    exit()\n\nrows = [[] for _ in range(numRows)]\ndirection = -1\ncurrent_row = 0\n\nfor char in s:\n    rows[current_row].append(char)\n    if current_row == 0 or current_row == numRows - 1:\n        direction *= -1\n    current_row += direction\n\nresult = []\nfor row in rows:\n    result.extend(row)\nprint(''.join(result))\nnums = [1]\nprint(nums[1])\n",
        "MLE": "s = input().strip()\nnumRows = int(input())\n\nif numRows == 1:\n    print(s)\n    exit()\n\nrows = [[] for _ in range(numRows)]\ndirection = -1\ncurrent_row = 0\n\nfor char in s:\n    rows[current_row].append(char)\n    if current_row == 0 or current_row == numRows - 1:\n        direction *= -1\n    current_row += direction\n\nresult = []\nfor row in rows:\n    result.extend(row)\nprint(''.join(result))\n# Create huge unnecessary data structure\nhuge_list = []\nfor i in range(10**7):  # Create 10M elements\n    huge_list.append([0] * 100)  # Each with 100 sub-elements\n",
        "TLE": "s = input().strip()\nnumRows = int(input())\n\nif numRows == 1:\n    print(s)\n    exit()\n\nrows = [[] for _ in range(numRows)]\ndirection = -1\ncurrent_row = 0\n\nfor char in s:\n    rows[current_row].append(char)\n    if current_row == 0 or current_row == numRows - 1:\n        direction *= -1\n    current_row += direction\n\nresult = []\nfor row in rows:\n    result.extend(row)\nprint(''.join(result))\nimport time\ntime.sleep(10)\n"
    },
    "p010": {
        "AC": "s = input().strip()\np = input().strip()\n\nmemo = {}\n\ndef dp(i, j):\n    if (i, j) not in memo:\n        if j == len(p):\n            ans = i == len(s)\n        else:\n            first_match = i < len(s) and p[j] in {s[i], '.'}\n            if j+1 < len(p) and p[j+1] == '*':\n                ans = dp(i, j+2) or (first_match and dp(i+1, j))\n            else:\n                ans = first_match and dp(i+1, j+1)\n        memo[i, j] = ans\n    return memo[i, j]\n\nprint(\"true\" if dp(0, 0) else \"false\")",
        "WA": "s = input().strip()\np = input().strip()\n\nmemo = {}\n\ndef dp(i, j):\n    if (i, j) not in memo:\n        if j == len(p):\n            ans = i == len(s)\n        else:\n            first_match = i < len(s) and p[j] in {s[i], '.'}\n            if j+1 < len(p) and p[j+1] == '*':\n                ans = dp(i, j+2) or (first_match and dp(i+1, j))\n            else:\n                ans = first_match and dp(i+1, j+1)\n        memo[i, j] = ans\n    return memo[i, j]\n\nprint(\"true\" if dp(0, 0) else \"false\")\nprint('wrong answer')\n",
        "RE": "s = input().strip()\np = input().strip()\n\nmemo = {}\n\ndef dp(i, j):\n    if (i, j) not in memo:\n        if j == len(p):\n            ans = i == len(s)\n        else:\n            first_match = i < len(s) and p[j] in {s[i], '.'}\n            if j+1 < len(p) and p[j+1] == '*':\n                ans = dp(i, j+2) or (first_match and dp(i+1, j))\n            else:\n                ans = first_match and dp(i+1, j+1)\n        memo[i, j] = ans\n    return memo[i, j]\n\nprint(\"true\" if dp(0, 0) else \"false\")\nnums = [1]\nprint(nums[1])\n",
        "MLE": "s = input().strip()\np = input().strip()\n\nmemo = {}\n\ndef dp(i, j):\n    if (i, j) not in memo:\n        if j == len(p):\n            ans = i == len(s)\n        else:\n            first_match = i < len(s) and p[j] in {s[i], '.'}\n            if j+1 < len(p) and p[j+1] == '*':\n                ans = dp(i, j+2) or (first_match and dp(i+1, j))\n            else:\n                ans = first_match and dp(i+1, j+1)\n        memo[i, j] = ans\n    return memo[i, j]\n\nprint(\"true\" if dp(0, 0) else \"false\")\n# Create huge unnecessary data structure\nhuge_list = []\nfor i in range(10**7):  # Create 10M elements\n    huge_list.append([0] * 100)  # Each with 100 sub-elements\n",
        "TLE": "s = input().strip()\np = input().strip()\n\nmemo = {}\n\ndef dp(i, j):\n    if (i, j) not in memo:\n        if j == len(p):\n            ans = i == len(s)\n        else:\n            first_match = i < len(s) and p[j] in {s[i], '.'}\n            if j+1 < len(p) and p[j+1] == '*':\n                ans = dp(i, j+2) or (first_match and dp(i+1, j))\n            else:\n                ans = first_match and dp(i+1, j+1)\n        memo[i, j] = ans\n    return memo[i, j]\n\nprint(\"true\" if dp(0, 0) else \"false\")\nimport time\ntime.sleep(10)\n"
    },
    "p014": {
        "AC": "n = int(input())\nstrs = [input().strip() for _ in range(n)]\n\nif not strs:\n    print(\"\")\n    exit()\n\nprefix = strs[0]\nfor s in strs[1:]:\n    while s[:len(prefix)] != prefix:\n        prefix = prefix[:-1]\n        if not prefix:\n            print(\"\")\n            exit()\n\nprint(prefix)",
        "WA": "n = int(input())\nstrs = [input().strip() for _ in range(n)]\n\nif not strs:\n    print(\"\")\n    exit()\n\nprefix = strs[0]\nfor s in strs[1:]:\n    while s[:len(prefix)] != prefix:\n        prefix = prefix[:-1]\n        if not prefix:\n            print(\"\")\n            exit()\n\nprint(prefix)\nprint('wrong answer')\n",
        "RE": "n = int(input())\nstrs = [input().strip() for _ in range(n)]\n\nif not strs:\n    print(\"\")\n    exit()\n\nprefix = strs[0]\nfor s in strs[1:]:\n    while s[:len(prefix)] != prefix:\n        prefix = prefix[:-1]\n        if not prefix:\n            print(\"\")\n            exit()\n\nprint(prefix)\nnums = [1]\nprint(nums[1])\n",
        "MLE": "n = int(input())\nstrs = [input().strip() for _ in range(n)]\n\nif not strs:\n    print(\"\")\n    exit()\n\nprefix = strs[0]\nfor s in strs[1:]:\n    while s[:len(prefix)] != prefix:\n        prefix = prefix[:-1]\n        if not prefix:\n            print(\"\")\n            exit()\n\nprint(prefix)\n# Create huge unnecessary data structure\nhuge_list = []\nfor i in range(10**7):  # Create 10M elements\n    huge_list.append([0] * 100)  # Each with 100 sub-elements\n",
        "TLE": "n = int(input())\nstrs = [input().strip() for _ in range(n)]\n\nif not strs:\n    print(\"\")\n    exit()\n\nprefix = strs[0]\nfor s in strs[1:]:\n    while s[:len(prefix)] != prefix:\n        prefix = prefix[:-1]\n        if not prefix:\n            print(\"\")\n            exit()\n\nprint(prefix)\nimport time\ntime.sleep(10)\n"
    },
    "p011": {
        "AC": "n, *heights = map(int, input().split())\n\nleft, right = 0, len(heights) - 1\nmax_area = 0\n\nwhile left < right:\n    width = right - left\n    height = min(heights[left], heights[right])\n    max_area = max(max_area, width * height)\n    \n    if heights[left] < heights[right]:\n        left += 1\n    else:\n        right -= 1\n\nprint(max_area)",
        "WA": "n, *heights = map(int, input().split())\n\nleft, right = 0, len(heights) - 1\nmax_area = 0\n\nwhile left < right:\n    width = right - left\n    height = min(heights[left], heights[right])\n    max_area = max(max_area, width * height)\n    \n    if heights[left] < heights[right]:\n        left += 1\n    else:\n        right -= 1\n\nprint(max_area)\nprint('wrong answer')\n",
        "RE": "n, *heights = map(int, input().split())\n\nleft, right = 0, len(heights) - 1\nmax_area = 0\n\nwhile left < right:\n    width = right - left\n    height = min(heights[left], heights[right])\n    max_area = max(max_area, width * height)\n    \n    if heights[left] < heights[right]:\n        left += 1\n    else:\n        right -= 1\n\nprint(max_area)\nnums = [1]\nprint(nums[1])\n",
        "MLE": "n, *heights = map(int, input().split())\n\nleft, right = 0, len(heights) - 1\nmax_area = 0\n\nwhile left < right:\n    width = right - left\n    height = min(heights[left], heights[right])\n    max_area = max(max_area, width * height)\n    \n    if heights[left] < heights[right]:\n        left += 1\n    else:\n        right -= 1\n\nprint(max_area)\n# Create huge unnecessary data structure\nhuge_list = []\nfor i in range(10**7):  # Create 10M elements\n    huge_list.append([0] * 100)  # Each with 100 sub-elements\n",
        "TLE": "n, *heights = map(int, input().split())\n\nleft, right = 0, len(heights) - 1\nmax_area = 0\n\nwhile left < right:\n    width = right - left\n    height = min(heights[left], heights[right])\n    max_area = max(max_area, width * height)\n    \n    if heights[left] < heights[right]:\n        left += 1\n    else:\n        right -= 1\n\nprint(max_area)\nimport time\ntime.sleep(10)\n"
    },
    "p005": {
        "AC": "s = input().strip()\n\ndef expand(l, r):\n    while l >= 0 and r < len(s) and s[l] == s[r]:\n        l -= 1\n        r += 1\n    return s[l+1:r]\n\nres = \"\"\nfor i in range(len(s)):\n    odd = expand(i, i)\n    even = expand(i, i+1) if i+1 < len(s) else \"\"\n    \n    if len(odd) > len(res):\n        res = odd\n    if len(even) > len(res):\n        res = even\n\nprint(res)",
        "WA": "s = input().strip()\n\ndef expand(l, r):\n    while l >= 0 and r < len(s) and s[l] == s[r]:\n        l -= 1\n        r += 1\n    return s[l+1:r]\n\nres = \"\"\nfor i in range(len(s)):\n    odd = expand(i, i)\n    even = expand(i, i+1) if i+1 < len(s) else \"\"\n    \n    if len(odd) > len(res):\n        res = odd\n    if len(even) > len(res):\n        res = even\n\nprint(res)\nprint('wrong answer')\n",
        "RE": "s = input().strip()\n\ndef expand(l, r):\n    while l >= 0 and r < len(s) and s[l] == s[r]:\n        l -= 1\n        r += 1\n    return s[l+1:r]\n\nres = \"\"\nfor i in range(len(s)):\n    odd = expand(i, i)\n    even = expand(i, i+1) if i+1 < len(s) else \"\"\n    \n    if len(odd) > len(res):\n        res = odd\n    if len(even) > len(res):\n        res = even\n\nprint(res)\nnums = [1]\nprint(nums[1])\n",
        "MLE": "s = input().strip()\n\ndef expand(l, r):\n    while l >= 0 and r < len(s) and s[l] == s[r]:\n        l -= 1\n        r += 1\n    return s[l+1:r]\n\nres = \"\"\nfor i in range(len(s)):\n    odd = expand(i, i)\n    even = expand(i, i+1) if i+1 < len(s) else \"\"\n    \n    if len(odd) > len(res):\n        res = odd\n    if len(even) > len(res):\n        res = even\n\nprint(res)\n# Create huge unnecessary data structure\nhuge_list = []\nfor i in range(10**7):  # Create 10M elements\n    huge_list.append([0] * 100)  # Each with 100 sub-elements\n",
        "TLE": "s = input().strip()\n\ndef expand(l, r):\n    while l >= 0 and r < len(s) and s[l] == s[r]:\n        l -= 1\n        r += 1\n    return s[l+1:r]\n\nres = \"\"\nfor i in range(len(s)):\n    odd = expand(i, i)\n    even = expand(i, i+1) if i+1 < len(s) else \"\"\n    \n    if len(odd) > len(res):\n        res = odd\n    if len(even) > len(res):\n        res = even\n\nprint(res)\nimport time\ntime.sleep(10)\n"
    },
    "p020": {
        "AC": "n = int(input())\n\nres = []\ndef backtrack(s='', left=0, right=0):\n    if len(s) == 2 * n:\n        res.append(s)\n        return\n    if left < n:\n        backtrack(s+'(', left+1, right)\n    if right < left:\n        backtrack(s+')', left, right+1)\n\nbacktrack()\nfor combination in res:\n    print(combination)",
        "WA": "n = int(input())\n\nres = []\ndef backtrack(s='', left=0, right=0):\n    if len(s) == 2 * n:\n        res.append(s)\n        return\n    if left < n:\n        backtrack(s+'(', left+1, right)\n    if right < left:\n        backtrack(s+')', left, right+1)\n\nbacktrack()\nfor combination in res:\n    print(combination)\nprint('wrong answer')\n",
        "RE": "n = int(input())\n\nres = []\ndef backtrack(s='', left=0, right=0):\n    if len(s) == 2 * n:\n        res.append(s)\n        return\n    if left < n:\n        backtrack(s+'(', left+1, right)\n    if right < left:\n        backtrack(s+')', left, right+1)\n\nbacktrack()\nfor combination in res:\n    print(combination)\nnums = [1]\nprint(nums[1])\n",
        "MLE": "n = int(input())\n\nres = []\ndef backtrack(s='', left=0, right=0):\n    if len(s) == 2 * n:\n        res.append(s)\n        return\n    if left < n:\n        backtrack(s+'(', left+1, right)\n    if right < left:\n        backtrack(s+')', left, right+1)\n\nbacktrack()\nfor combination in res:\n    print(combination)\n# Create huge unnecessary data structure\nhuge_list = []\nfor i in range(10**7):  # Create 10M elements\n    huge_list.append([0] * 100)  # Each with 100 sub-elements\n",
        "TLE": "n = int(input())\n\nres = []\ndef backtrack(s='', left=0, right=0):\n    if len(s) == 2 * n:\n        res.append(s)\n        return\n    if left < n:\n        backtrack(s+'(', left+1, right)\n    if right < left:\n        backtrack(s+')', left, right+1)\n\nbacktrack()\nfor combination in res:\n    print(combination)\nimport time\ntime.sleep(10)\n"
    },
    "p017": {
        "AC": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nm = int(input())\nelements = list(map(int, input().split()))\nn = int(input())\n\ndummy = ListNode(0)\ncurrent = dummy\nfor val in elements:\n    current.next = ListNode(val)\n    current = current.next\n\nfast = slow = dummy\nfor _ in range(n+1):\n    fast = fast.next\n\nwhile fast:\n    fast = fast.next\n    slow = slow.next\n\nslow.next = slow.next.next\n\nresult = []\ncurrent = dummy.next\nwhile current:\n    result.append(str(current.val))\n    current = current.next\n\nprint(' '.join(result) if result else \"\")",
        "WA": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nm = int(input())\nelements = list(map(int, input().split()))\nn = int(input())\n\ndummy = ListNode(0)\ncurrent = dummy\nfor val in elements:\n    current.next = ListNode(val)\n    current = current.next\n\nfast = slow = dummy\nfor _ in range(n+1):\n    fast = fast.next\n\nwhile fast:\n    fast = fast.next\n    slow = slow.next\n\nslow.next = slow.next.next\n\nresult = []\ncurrent = dummy.next\nwhile current:\n    result.append(str(current.val))\n    current = current.next\n\nprint(' '.join(result) if result else \"\")\nprint('wrong answer')\n",
        "RE": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nm = int(input())\nelements = list(map(int, input().split()))\nn = int(input())\n\ndummy = ListNode(0)\ncurrent = dummy\nfor val in elements:\n    current.next = ListNode(val)\n    current = current.next\n\nfast = slow = dummy\nfor _ in range(n+1):\n    fast = fast.next\n\nwhile fast:\n    fast = fast.next\n    slow = slow.next\n\nslow.next = slow.next.next\n\nresult = []\ncurrent = dummy.next\nwhile current:\n    result.append(str(current.val))\n    current = current.next\n\nprint(' '.join(result) if result else \"\")\nnums = [1]\nprint(nums[1])\n",
        "MLE": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nm = int(input())\nelements = list(map(int, input().split()))\nn = int(input())\n\ndummy = ListNode(0)\ncurrent = dummy\nfor val in elements:\n    current.next = ListNode(val)\n    current = current.next\n\nfast = slow = dummy\nfor _ in range(n+1):\n    fast = fast.next\n\nwhile fast:\n    fast = fast.next\n    slow = slow.next\n\nslow.next = slow.next.next\n\nresult = []\ncurrent = dummy.next\nwhile current:\n    result.append(str(current.val))\n    current = current.next\n\nprint(' '.join(result) if result else \"\")\n# Create huge unnecessary data structure\nhuge_list = []\nfor i in range(10**7):  # Create 10M elements\n    huge_list.append([0] * 100)  # Each with 100 sub-elements\n",
        "TLE": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nm = int(input())\nelements = list(map(int, input().split()))\nn = int(input())\n\ndummy = ListNode(0)\ncurrent = dummy\nfor val in elements:\n    current.next = ListNode(val)\n    current = current.next\n\nfast = slow = dummy\nfor _ in range(n+1):\n    fast = fast.next\n\nwhile fast:\n    fast = fast.next\n    slow = slow.next\n\nslow.next = slow.next.next\n\nresult = []\ncurrent = dummy.next\nwhile current:\n    result.append(str(current.val))\n    current = current.next\n\nprint(' '.join(result) if result else \"\")\nimport time\ntime.sleep(10)\n"
    },
    "p013": {
        "AC": "s = input().strip()\n\nroman = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\ntotal = 0\nprev = 0\n\nfor char in reversed(s):\n    curr = roman[char]\n    if curr < prev:\n        total -= curr\n    else:\n        total += curr\n    prev = curr\n\nprint(total)",
        "WA": "s = input().strip()\n\nroman = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\ntotal = 0\nprev = 0\n\nfor char in reversed(s):\n    curr = roman[char]\n    if curr < prev:\n        total -= curr\n    else:\n        total += curr\n    prev = curr\n\nprint(total)\nprint('wrong answer')\n",
        "RE": "s = input().strip()\n\nroman = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\ntotal = 0\nprev = 0\n\nfor char in reversed(s):\n    curr = roman[char]\n    if curr < prev:\n        total -= curr\n    else:\n        total += curr\n    prev = curr\n\nprint(total)\nnums = [1]\nprint(nums[1])\n",
        "MLE": "s = input().strip()\n\nroman = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\ntotal = 0\nprev = 0\n\nfor char in reversed(s):\n    curr = roman[char]\n    if curr < prev:\n        total -= curr\n    else:\n        total += curr\n    prev = curr\n\nprint(total)\n# Create huge unnecessary data structure\nhuge_list = []\nfor i in range(10**7):  # Create 10M elements\n    huge_list.append([0] * 100)  # Each with 100 sub-elements\n",
        "TLE": "s = input().strip()\n\nroman = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\ntotal = 0\nprev = 0\n\nfor char in reversed(s):\n    curr = roman[char]\n    if curr < prev:\n        total -= curr\n    else:\n        total += curr\n    prev = curr\n\nprint(total)\nimport time\ntime.sleep(10)\n"
    },
    "p012": {
        "AC": "num = int(input())\n\nval_sym = [\n    (1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"),\n    (100, \"C\"), (90, \"XC\"), (50, \"L\"), (40, \"XL\"),\n    (10, \"X\"), (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")\n]\n\nres = []\nfor val, sym in val_sym:\n    if num == 0:\n        break\n    count, num = divmod(num, val)\n    res.append(sym * count)\n\nprint(''.join(res))",
        "WA": "num = int(input())\n\nval_sym = [\n    (1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"),\n    (100, \"C\"), (90, \"XC\"), (50, \"L\"), (40, \"XL\"),\n    (10, \"X\"), (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")\n]\n\nres = []\nfor val, sym in val_sym:\n    if num == 0:\n        break\n    count, num = divmod(num, val)\n    res.append(sym * count)\n\nprint(''.join(res))\nprint('wrong answer')\n",
        "RE": "num = int(input())\n\nval_sym = [\n    (1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"),\n    (100, \"C\"), (90, \"XC\"), (50, \"L\"), (40, \"XL\"),\n    (10, \"X\"), (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")\n]\n\nres = []\nfor val, sym in val_sym:\n    if num == 0:\n        break\n    count, num = divmod(num, val)\n    res.append(sym * count)\n\nprint(''.join(res))\nnums = [1]\nprint(nums[1])\n",
        "MLE": "num = int(input())\n\nval_sym = [\n    (1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"),\n    (100, \"C\"), (90, \"XC\"), (50, \"L\"), (40, \"XL\"),\n    (10, \"X\"), (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")\n]\n\nres = []\nfor val, sym in val_sym:\n    if num == 0:\n        break\n    count, num = divmod(num, val)\n    res.append(sym * count)\n\nprint(''.join(res))\n# Create huge unnecessary data structure\nhuge_list = []\nfor i in range(10**7):  # Create 10M elements\n    huge_list.append([0] * 100)  # Each with 100 sub-elements\n",
        "TLE": "num = int(input())\n\nval_sym = [\n    (1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"),\n    (100, \"C\"), (90, \"XC\"), (50, \"L\"), (40, \"XL\"),\n    (10, \"X\"), (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")\n]\n\nres = []\nfor val, sym in val_sym:\n    if num == 0:\n        break\n    count, num = divmod(num, val)\n    res.append(sym * count)\n\nprint(''.join(res))\nimport time\ntime.sleep(10)\n"
    },
    "p002": {
        "AC": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nn = int(input())\nl1_digits = list(map(int, input().split()))\nm = int(input())\nl2_digits = list(map(int, input().split()))\n\n# Helper function to create linked list\ndef create_list(digits):\n    if not digits:\n        return None\n    head = ListNode(digits[0])\n    current = head\n    for digit in digits[1:]:\n        current.next = ListNode(digit)\n        current = current.next\n    return head\n\nl1 = create_list(l1_digits)\nl2 = create_list(l2_digits)\n\ndummy = ListNode()\ncurrent = dummy\ncarry = 0\n\nwhile l1 or l2 or carry:\n    sum_val = carry\n    if l1:\n        sum_val += l1.val\n        l1 = l1.next\n    if l2:\n        sum_val += l2.val\n        l2 = l2.next\n    \n    carry = sum_val // 10\n    current.next = ListNode(sum_val % 10)\n    current = current.next\n\nresult = []\ncurrent = dummy.next\nwhile current:\n    result.append(str(current.val))\n    current = current.next\n\nprint(' '.join(result))",
        "WA": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nn = int(input())\nl1_digits = list(map(int, input().split()))\nm = int(input())\nl2_digits = list(map(int, input().split()))\n\n# Helper function to create linked list\ndef create_list(digits):\n    if not digits:\n        return None\n    head = ListNode(digits[0])\n    current = head\n    for digit in digits[1:]:\n        current.next = ListNode(digit)\n        current = current.next\n    return head\n\nl1 = create_list(l1_digits)\nl2 = create_list(l2_digits)\n\ndummy = ListNode()\ncurrent = dummy\ncarry = 0\n\nwhile l1 or l2 or carry:\n    sum_val = carry\n    if l1:\n        sum_val += l1.val\n        l1 = l1.next\n    if l2:\n        sum_val += l2.val\n        l2 = l2.next\n    \n    carry = sum_val // 10\n    current.next = ListNode(sum_val % 10)\n    current = current.next\n\nresult = []\ncurrent = dummy.next\nwhile current:\n    result.append(str(current.val))\n    current = current.next\n\nprint(' '.join(result))\nprint('wrong answer')\n",
        "RE": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nn = int(input())\nl1_digits = list(map(int, input().split()))\nm = int(input())\nl2_digits = list(map(int, input().split()))\n\n# Helper function to create linked list\ndef create_list(digits):\n    if not digits:\n        return None\n    head = ListNode(digits[0])\n    current = head\n    for digit in digits[1:]:\n        current.next = ListNode(digit)\n        current = current.next\n    return head\n\nl1 = create_list(l1_digits)\nl2 = create_list(l2_digits)\n\ndummy = ListNode()\ncurrent = dummy\ncarry = 0\n\nwhile l1 or l2 or carry:\n    sum_val = carry\n    if l1:\n        sum_val += l1.val\n        l1 = l1.next\n    if l2:\n        sum_val += l2.val\n        l2 = l2.next\n    \n    carry = sum_val // 10\n    current.next = ListNode(sum_val % 10)\n    current = current.next\n\nresult = []\ncurrent = dummy.next\nwhile current:\n    result.append(str(current.val))\n    current = current.next\n\nprint(' '.join(result))\nnums = [1]\nprint(nums[1])\n",
        "MLE": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nn = int(input())\nl1_digits = list(map(int, input().split()))\nm = int(input())\nl2_digits = list(map(int, input().split()))\n\n# Helper function to create linked list\ndef create_list(digits):\n    if not digits:\n        return None\n    head = ListNode(digits[0])\n    current = head\n    for digit in digits[1:]:\n        current.next = ListNode(digit)\n        current = current.next\n    return head\n\nl1 = create_list(l1_digits)\nl2 = create_list(l2_digits)\n\ndummy = ListNode()\ncurrent = dummy\ncarry = 0\n\nwhile l1 or l2 or carry:\n    sum_val = carry\n    if l1:\n        sum_val += l1.val\n        l1 = l1.next\n    if l2:\n        sum_val += l2.val\n        l2 = l2.next\n    \n    carry = sum_val // 10\n    current.next = ListNode(sum_val % 10)\n    current = current.next\n\nresult = []\ncurrent = dummy.next\nwhile current:\n    result.append(str(current.val))\n    current = current.next\n\nprint(' '.join(result))\n# Create huge unnecessary data structure\nhuge_list = []\nfor i in range(10**7):  # Create 10M elements\n    huge_list.append([0] * 100)  # Each with 100 sub-elements\n",
        "TLE": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nn = int(input())\nl1_digits = list(map(int, input().split()))\nm = int(input())\nl2_digits = list(map(int, input().split()))\n\n# Helper function to create linked list\ndef create_list(digits):\n    if not digits:\n        return None\n    head = ListNode(digits[0])\n    current = head\n    for digit in digits[1:]:\n        current.next = ListNode(digit)\n        current = current.next\n    return head\n\nl1 = create_list(l1_digits)\nl2 = create_list(l2_digits)\n\ndummy = ListNode()\ncurrent = dummy\ncarry = 0\n\nwhile l1 or l2 or carry:\n    sum_val = carry\n    if l1:\n        sum_val += l1.val\n        l1 = l1.next\n    if l2:\n        sum_val += l2.val\n        l2 = l2.next\n    \n    carry = sum_val // 10\n    current.next = ListNode(sum_val % 10)\n    current = current.next\n\nresult = []\ncurrent = dummy.next\nwhile current:\n    result.append(str(current.val))\n    current = current.next\n\nprint(' '.join(result))\nimport time\ntime.sleep(10)\n"
    },
    "p015": {
        "AC": "n, *nums = map(int, input().split())\n\nnums.sort()\nres = []\n\nfor i in range(len(nums)):\n    if i > 0 and nums[i] == nums[i-1]:\n        continue\n    \n    left, right = i+1, len(nums)-1\n    while left < right:\n        total = nums[i] + nums[left] + nums[right]\n        if total < 0:\n            left += 1\n        elif total > 0:\n            right -= 1\n        else:\n            res.append([nums[i], nums[left], nums[right]])\n            while left < right and nums[left] == nums[left+1]:\n                left += 1\n            while left < right and nums[right] == nums[right-1]:\n                right -= 1\n            left += 1\n            right -= 1\n\nfor triplet in res:\n    print(' '.join(map(str, triplet)))",
        "WA": "n, *nums = map(int, input().split())\n\nnums.sort()\nres = []\n\nfor i in range(len(nums)):\n    if i > 0 and nums[i] == nums[i-1]:\n        continue\n    \n    left, right = i+1, len(nums)-1\n    while left < right:\n        total = nums[i] + nums[left] + nums[right]\n        if total < 0:\n            left += 1\n        elif total > 0:\n            right -= 1\n        else:\n            res.append([nums[i], nums[left], nums[right]])\n            while left < right and nums[left] == nums[left+1]:\n                left += 1\n            while left < right and nums[right] == nums[right-1]:\n                right -= 1\n            left += 1\n            right -= 1\n\nfor triplet in res:\n    print(' '.join(map(str, triplet)))\nprint('wrong answer')\n",
        "RE": "n, *nums = map(int, input().split())\n\nnums.sort()\nres = []\n\nfor i in range(len(nums)):\n    if i > 0 and nums[i] == nums[i-1]:\n        continue\n    \n    left, right = i+1, len(nums)-1\n    while left < right:\n        total = nums[i] + nums[left] + nums[right]\n        if total < 0:\n            left += 1\n        elif total > 0:\n            right -= 1\n        else:\n            res.append([nums[i], nums[left], nums[right]])\n            while left < right and nums[left] == nums[left+1]:\n                left += 1\n            while left < right and nums[right] == nums[right-1]:\n                right -= 1\n            left += 1\n            right -= 1\n\nfor triplet in res:\n    print(' '.join(map(str, triplet)))\nnums = [1]\nprint(nums[1])\n",
        "MLE": "n, *nums = map(int, input().split())\n\nnums.sort()\nres = []\n\nfor i in range(len(nums)):\n    if i > 0 and nums[i] == nums[i-1]:\n        continue\n    \n    left, right = i+1, len(nums)-1\n    while left < right:\n        total = nums[i] + nums[left] + nums[right]\n        if total < 0:\n            left += 1\n        elif total > 0:\n            right -= 1\n        else:\n            res.append([nums[i], nums[left], nums[right]])\n            while left < right and nums[left] == nums[left+1]:\n                left += 1\n            while left < right and nums[right] == nums[right-1]:\n                right -= 1\n            left += 1\n            right -= 1\n\nfor triplet in res:\n    print(' '.join(map(str, triplet)))\n# Create huge unnecessary data structure\nhuge_list = []\nfor i in range(10**7):  # Create 10M elements\n    huge_list.append([0] * 100)  # Each with 100 sub-elements\n",
        "TLE": "n, *nums = map(int, input().split())\n\nnums.sort()\nres = []\n\nfor i in range(len(nums)):\n    if i > 0 and nums[i] == nums[i-1]:\n        continue\n    \n    left, right = i+1, len(nums)-1\n    while left < right:\n        total = nums[i] + nums[left] + nums[right]\n        if total < 0:\n            left += 1\n        elif total > 0:\n            right -= 1\n        else:\n            res.append([nums[i], nums[left], nums[right]])\n            while left < right and nums[left] == nums[left+1]:\n                left += 1\n            while left < right and nums[right] == nums[right-1]:\n                right -= 1\n            left += 1\n            right -= 1\n\nfor triplet in res:\n    print(' '.join(map(str, triplet)))\nimport time\ntime.sleep(10)\n"
    },
    "p018": {
        "AC": "s = input().strip()\n\nstack = []\nmapping = {')': '(', '}': '{', ']': '['}\n\nfor char in s:\n    if char in mapping:\n        top = stack.pop() if stack else '#'\n        if mapping[char] != top:\n            print(\"false\")\n            exit()\n    else:\n        stack.append(char)\n\nprint(\"true\" if not stack else \"false\")",
        "WA": "s = input().strip()\n\nstack = []\nmapping = {')': '(', '}': '{', ']': '['}\n\nfor char in s:\n    if char in mapping:\n        top = stack.pop() if stack else '#'\n        if mapping[char] != top:\n            print(\"false\")\n            exit()\n    else:\n        stack.append(char)\n\nprint(\"true\" if not stack else \"false\")\nprint('wrong answer')\n",
        "RE": "s = input().strip()\n\nstack = []\nmapping = {')': '(', '}': '{', ']': '['}\n\nfor char in s:\n    if char in mapping:\n        top = stack.pop() if stack else '#'\n        if mapping[char] != top:\n            print(\"false\")\n            exit()\n    else:\n        stack.append(char)\n\nprint(\"true\" if not stack else \"false\")\nnums = [1]\nprint(nums[1])\n",
        "MLE": "s = input().strip()\n\nstack = []\nmapping = {')': '(', '}': '{', ']': '['}\n\nfor char in s:\n    if char in mapping:\n        top = stack.pop() if stack else '#'\n        if mapping[char] != top:\n            print(\"false\")\n            exit()\n    else:\n        stack.append(char)\n\nprint(\"true\" if not stack else \"false\")\n# Create huge unnecessary data structure\nhuge_list = []\nfor i in range(10**7):  # Create 10M elements\n    huge_list.append([0] * 100)  # Each with 100 sub-elements\n",
        "TLE": "s = input().strip()\n\nstack = []\nmapping = {')': '(', '}': '{', ']': '['}\n\nfor char in s:\n    if char in mapping:\n        top = stack.pop() if stack else '#'\n        if mapping[char] != top:\n            print(\"false\")\n            exit()\n    else:\n        stack.append(char)\n\nprint(\"true\" if not stack else \"false\")\nimport time\ntime.sleep(10)\n"
    },
    "p003": {
        "AC": "s = input().strip()\n\nchar_set = set()\nleft = 0\nmax_len = 0\n\nfor right in range(len(s)):\n    while s[right] in char_set:\n        char_set.remove(s[left])\n        left += 1\n    char_set.add(s[right])\n    max_len = max(max_len, right - left + 1)\n\nprint(max_len)",
        "WA": "s = input().strip()\n\nchar_set = set()\nleft = 0\nmax_len = 0\n\nfor right in range(len(s)):\n    while s[right] in char_set:\n        char_set.remove(s[left])\n        left += 1\n    char_set.add(s[right])\n    max_len = max(max_len, right - left + 1)\n\nprint(max_len)\nprint('wrong answer')\n",
        "RE": "s = input().strip()\n\nchar_set = set()\nleft = 0\nmax_len = 0\n\nfor right in range(len(s)):\n    while s[right] in char_set:\n        char_set.remove(s[left])\n        left += 1\n    char_set.add(s[right])\n    max_len = max(max_len, right - left + 1)\n\nprint(max_len)\nnums = [1]\nprint(nums[1])\n",
        "MLE": "s = input().strip()\n\nchar_set = set()\nleft = 0\nmax_len = 0\n\nfor right in range(len(s)):\n    while s[right] in char_set:\n        char_set.remove(s[left])\n        left += 1\n    char_set.add(s[right])\n    max_len = max(max_len, right - left + 1)\n\nprint(max_len)\n# Create huge unnecessary data structure\nhuge_list = []\nfor i in range(10**7):  # Create 10M elements\n    huge_list.append([0] * 100)  # Each with 100 sub-elements\n",
        "TLE": "s = input().strip()\n\nchar_set = set()\nleft = 0\nmax_len = 0\n\nfor right in range(len(s)):\n    while s[right] in char_set:\n        char_set.remove(s[left])\n        left += 1\n    char_set.add(s[right])\n    max_len = max(max_len, right - left + 1)\n\nprint(max_len)\nimport time\ntime.sleep(10)\n"
    },
    "p004": {
        "AC": "m, *nums1 = map(int, input().split())\nn, *nums2 = map(int, input().split())\n\nA, B = nums1, nums2\nif len(A) > len(B):\n    A, B = B, A\n\ntotal = len(A) + len(B)\nhalf = total // 2\n\nleft, right = 0, len(A) - 1\nwhile True:\n    i = (left + right) // 2\n    j = half - i - 2\n    \n    Aleft = A[i] if i >= 0 else float('-inf')\n    Aright = A[i+1] if (i+1) < len(A) else float('inf')\n    Bleft = B[j] if j >= 0 else float('-inf')\n    Bright = B[j+1] if (j+1) < len(B) else float('inf')\n    \n    if Aleft <= Bright and Bleft <= Aright:\n        if total % 2:\n            print(float(min(Aright, Bright)))\n        else:\n            print((max(Aleft, Bleft) + min(Aright, Bright)) / 2)\n        break\n    elif Aleft > Bright:\n        right = i - 1\n    else:\n        left = i + 1",
        "WA": "m, *nums1 = map(int, input().split())\nn, *nums2 = map(int, input().split())\n\nA, B = nums1, nums2\nif len(A) > len(B):\n    A, B = B, A\n\ntotal = len(A) + len(B)\nhalf = total // 2\n\nleft, right = 0, len(A) - 1\nwhile True:\n    i = (left + right) // 2\n    j = half - i - 2\n    \n    Aleft = A[i] if i >= 0 else float('-inf')\n    Aright = A[i+1] if (i+1) < len(A) else float('inf')\n    Bleft = B[j] if j >= 0 else float('-inf')\n    Bright = B[j+1] if (j+1) < len(B) else float('inf')\n    \n    if Aleft <= Bright and Bleft <= Aright:\n        if total % 2:\n            print(float(min(Aright, Bright)))\n        else:\n            print((max(Aleft, Bleft) + min(Aright, Bright)) / 2)\n        break\n    elif Aleft > Bright:\n        right = i - 1\n    else:\n        left = i + 1\nprint('wrong answer')\n",
        "RE": "m, *nums1 = map(int, input().split())\nn, *nums2 = map(int, input().split())\n\nA, B = nums1, nums2\nif len(A) > len(B):\n    A, B = B, A\n\ntotal = len(A) + len(B)\nhalf = total // 2\n\nleft, right = 0, len(A) - 1\nwhile True:\n    i = (left + right) // 2\n    j = half - i - 2\n    \n    Aleft = A[i] if i >= 0 else float('-inf')\n    Aright = A[i+1] if (i+1) < len(A) else float('inf')\n    Bleft = B[j] if j >= 0 else float('-inf')\n    Bright = B[j+1] if (j+1) < len(B) else float('inf')\n    \n    if Aleft <= Bright and Bleft <= Aright:\n        if total % 2:\n            print(float(min(Aright, Bright)))\n        else:\n            print((max(Aleft, Bleft) + min(Aright, Bright)) / 2)\n        break\n    elif Aleft > Bright:\n        right = i - 1\n    else:\n        left = i + 1\nnums = [1]\nprint(nums[1])\n",
        "MLE": "m, *nums1 = map(int, input().split())\nn, *nums2 = map(int, input().split())\n\nA, B = nums1, nums2\nif len(A) > len(B):\n    A, B = B, A\n\ntotal = len(A) + len(B)\nhalf = total // 2\n\nleft, right = 0, len(A) - 1\nwhile True:\n    i = (left + right) // 2\n    j = half - i - 2\n    \n    Aleft = A[i] if i >= 0 else float('-inf')\n    Aright = A[i+1] if (i+1) < len(A) else float('inf')\n    Bleft = B[j] if j >= 0 else float('-inf')\n    Bright = B[j+1] if (j+1) < len(B) else float('inf')\n    \n    if Aleft <= Bright and Bleft <= Aright:\n        if total % 2:\n            print(float(min(Aright, Bright)))\n        else:\n            print((max(Aleft, Bleft) + min(Aright, Bright)) / 2)\n        break\n    elif Aleft > Bright:\n        right = i - 1\n    else:\n        left = i + 1\n# Create huge unnecessary data structure\nhuge_list = []\nfor i in range(10**7):  # Create 10M elements\n    huge_list.append([0] * 100)  # Each with 100 sub-elements\n",
        "TLE": "m, *nums1 = map(int, input().split())\nn, *nums2 = map(int, input().split())\n\nA, B = nums1, nums2\nif len(A) > len(B):\n    A, B = B, A\n\ntotal = len(A) + len(B)\nhalf = total // 2\n\nleft, right = 0, len(A) - 1\nwhile True:\n    i = (left + right) // 2\n    j = half - i - 2\n    \n    Aleft = A[i] if i >= 0 else float('-inf')\n    Aright = A[i+1] if (i+1) < len(A) else float('inf')\n    Bleft = B[j] if j >= 0 else float('-inf')\n    Bright = B[j+1] if (j+1) < len(B) else float('inf')\n    \n    if Aleft <= Bright and Bleft <= Aright:\n        if total % 2:\n            print(float(min(Aright, Bright)))\n        else:\n            print((max(Aleft, Bleft) + min(Aright, Bright)) / 2)\n        break\n    elif Aleft > Bright:\n        right = i - 1\n    else:\n        left = i + 1\nimport time\ntime.sleep(10)\n"
    },
    "p009": {
        "AC": "x = int(input())\n\nif x < 0:\n    print(\"false\")\n    exit()\n\noriginal = x\nreversed_num = 0\n\nwhile x > 0:\n    digit = x % 10\n    reversed_num = reversed_num * 10 + digit\n    x = x // 10\n\nprint(\"true\" if original == reversed_num else \"false\")",
        "WA": "x = int(input())\n\nif x < 0:\n    print(\"false\")\n    exit()\n\noriginal = x\nreversed_num = 0\n\nwhile x > 0:\n    digit = x % 10\n    reversed_num = reversed_num * 10 + digit\n    x = x // 10\n\nprint(\"true\" if original == reversed_num else \"false\")\nprint('wrong answer')\n",
        "RE": "x = int(input())\n\nif x < 0:\n    print(\"false\")\n    exit()\n\noriginal = x\nreversed_num = 0\n\nwhile x > 0:\n    digit = x % 10\n    reversed_num = reversed_num * 10 + digit\n    x = x // 10\n\nprint(\"true\" if original == reversed_num else \"false\")\nnums = [1]\nprint(nums[1])\n",
        "MLE": "x = int(input())\n\nif x < 0:\n    print(\"false\")\n    exit()\n\noriginal = x\nreversed_num = 0\n\nwhile x > 0:\n    digit = x % 10\n    reversed_num = reversed_num * 10 + digit\n    x = x // 10\n\nprint(\"true\" if original == reversed_num else \"false\")\n# Create huge unnecessary data structure\nhuge_list = []\nfor i in range(10**7):  # Create 10M elements\n    huge_list.append([0] * 100)  # Each with 100 sub-elements\n",
        "TLE": "x = int(input())\n\nif x < 0:\n    print(\"false\")\n    exit()\n\noriginal = x\nreversed_num = 0\n\nwhile x > 0:\n    digit = x % 10\n    reversed_num = reversed_num * 10 + digit\n    x = x // 10\n\nprint(\"true\" if original == reversed_num else \"false\")\nimport time\ntime.sleep(10)\n"
    },
    "p001": {
        "AC": "n = int(input())\nnums = list(map(int, input().split()))\ntarget = int(input())\n\nhash_map = {}\nfor i, num in enumerate(nums):\n    complement = target - num\n    if complement in hash_map:\n        print(hash_map[complement], i)\n        exit()\n    hash_map[num] = i",
        "WA": "n = int(input())\nnums = list(map(int, input().split()))\ntarget = int(input())\n\nhash_map = {}\nfor i, num in enumerate(nums):\n    complement = target - num\n    if complement in hash_map:\n        print(hash_map[complement], i)\n        exit()\n    hash_map[num] = i\nprint('wrong answer')\n",
        "RE": "n = int(input())\nnums = list(map(int, input().split()))\ntarget = int(input())\n\nhash_map = {}\nfor i, num in enumerate(nums):\n    complement = target - num\n    if complement in hash_map:\n        print(hash_map[complement], i)\n        exit()\n    hash_map[num] = i\nnums = [1]\nprint(nums[1])\n",
        "MLE": "n = int(input())\nnums = list(map(int, input().split()))\ntarget = int(input())\n\nhash_map = {}\nfor i, num in enumerate(nums):\n    complement = target - num\n    if complement in hash_map:\n        print(hash_map[complement], i)\n        exit()\n    hash_map[num] = i\n# Create huge unnecessary data structure\nhuge_list = []\nfor i in range(10**7):  # Create 10M elements\n    huge_list.append([0] * 100)  # Each with 100 sub-elements\n",
        "TLE": "n = int(input())\nnums = list(map(int, input().split()))\ntarget = int(input())\n\nhash_map = {}\nfor i, num in enumerate(nums):\n    complement = target - num\n    if complement in hash_map:\n        print(hash_map[complement], i)\n        exit()\n    hash_map[num] = i\nimport time\ntime.sleep(10)\n"
    },
    "p019": {
        "AC": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nm, *list1 = map(int, input().split())\nn, *list2 = map(int, input().split())\n\ndef create_list(elements):\n    dummy = ListNode()\n    current = dummy\n    for val in elements:\n        current.next = ListNode(val)\n        current = current.next\n    return dummy.next\n\nl1 = create_list(list1)\nl2 = create_list(list2)\n\ndummy = ListNode()\ncurrent = dummy\n\nwhile l1 and l2:\n    if l1.val <= l2.val:\n        current.next = l1\n        l1 = l1.next\n    else:\n        current.next = l2\n        l2 = l2.next\n    current = current.next\n\ncurrent.next = l1 if l1 else l2\n\nresult = []\ncurrent = dummy.next\nwhile current:\n    result.append(str(current.val))\n    current = current.next\n\nprint(' '.join(result) if result else \"\")",
        "WA": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nm, *list1 = map(int, input().split())\nn, *list2 = map(int, input().split())\n\ndef create_list(elements):\n    dummy = ListNode()\n    current = dummy\n    for val in elements:\n        current.next = ListNode(val)\n        current = current.next\n    return dummy.next\n\nl1 = create_list(list1)\nl2 = create_list(list2)\n\ndummy = ListNode()\ncurrent = dummy\n\nwhile l1 and l2:\n    if l1.val <= l2.val:\n        current.next = l1\n        l1 = l1.next\n    else:\n        current.next = l2\n        l2 = l2.next\n    current = current.next\n\ncurrent.next = l1 if l1 else l2\n\nresult = []\ncurrent = dummy.next\nwhile current:\n    result.append(str(current.val))\n    current = current.next\n\nprint(' '.join(result) if result else \"\")\nprint('wrong answer')\n",
        "RE": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nm, *list1 = map(int, input().split())\nn, *list2 = map(int, input().split())\n\ndef create_list(elements):\n    dummy = ListNode()\n    current = dummy\n    for val in elements:\n        current.next = ListNode(val)\n        current = current.next\n    return dummy.next\n\nl1 = create_list(list1)\nl2 = create_list(list2)\n\ndummy = ListNode()\ncurrent = dummy\n\nwhile l1 and l2:\n    if l1.val <= l2.val:\n        current.next = l1\n        l1 = l1.next\n    else:\n        current.next = l2\n        l2 = l2.next\n    current = current.next\n\ncurrent.next = l1 if l1 else l2\n\nresult = []\ncurrent = dummy.next\nwhile current:\n    result.append(str(current.val))\n    current = current.next\n\nprint(' '.join(result) if result else \"\")\nnums = [1]\nprint(nums[1])\n",
        "MLE": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nm, *list1 = map(int, input().split())\nn, *list2 = map(int, input().split())\n\ndef create_list(elements):\n    dummy = ListNode()\n    current = dummy\n    for val in elements:\n        current.next = ListNode(val)\n        current = current.next\n    return dummy.next\n\nl1 = create_list(list1)\nl2 = create_list(list2)\n\ndummy = ListNode()\ncurrent = dummy\n\nwhile l1 and l2:\n    if l1.val <= l2.val:\n        current.next = l1\n        l1 = l1.next\n    else:\n        current.next = l2\n        l2 = l2.next\n    current = current.next\n\ncurrent.next = l1 if l1 else l2\n\nresult = []\ncurrent = dummy.next\nwhile current:\n    result.append(str(current.val))\n    current = current.next\n\nprint(' '.join(result) if result else \"\")\n# Create huge unnecessary data structure\nhuge_list = []\nfor i in range(10**7):  # Create 10M elements\n    huge_list.append([0] * 100)  # Each with 100 sub-elements\n",
        "TLE": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nm, *list1 = map(int, input().split())\nn, *list2 = map(int, input().split())\n\ndef create_list(elements):\n    dummy = ListNode()\n    current = dummy\n    for val in elements:\n        current.next = ListNode(val)\n        current = current.next\n    return dummy.next\n\nl1 = create_list(list1)\nl2 = create_list(list2)\n\ndummy = ListNode()\ncurrent = dummy\n\nwhile l1 and l2:\n    if l1.val <= l2.val:\n        current.next = l1\n        l1 = l1.next\n    else:\n        current.next = l2\n        l2 = l2.next\n    current = current.next\n\ncurrent.next = l1 if l1 else l2\n\nresult = []\ncurrent = dummy.next\nwhile current:\n    result.append(str(current.val))\n    current = current.next\n\nprint(' '.join(result) if result else \"\")\nimport time\ntime.sleep(10)\n"
    },
    "p007": {
        "AC": "x = int(input())\n\nsign = -1 if x < 0 else 1\nx = abs(x)\nrev = 0\n\nwhile x != 0:\n    pop = x % 10\n    x = x // 10\n    rev = rev * 10 + pop\n\nrev *= sign\n\nif rev < -2**31 or rev > 2**31 - 1:\n    print(0)\nelse:\n    print(rev)",
        "WA": "x = int(input())\n\nsign = -1 if x < 0 else 1\nx = abs(x)\nrev = 0\n\nwhile x != 0:\n    pop = x % 10\n    x = x // 10\n    rev = rev * 10 + pop\n\nrev *= sign\n\nif rev < -2**31 or rev > 2**31 - 1:\n    print(0)\nelse:\n    print(rev)\nprint('wrong answer')\n",
        "RE": "x = int(input())\n\nsign = -1 if x < 0 else 1\nx = abs(x)\nrev = 0\n\nwhile x != 0:\n    pop = x % 10\n    x = x // 10\n    rev = rev * 10 + pop\n\nrev *= sign\n\nif rev < -2**31 or rev > 2**31 - 1:\n    print(0)\nelse:\n    print(rev)\nnums = [1]\nprint(nums[1])\n",
        "MLE": "x = int(input())\n\nsign = -1 if x < 0 else 1\nx = abs(x)\nrev = 0\n\nwhile x != 0:\n    pop = x % 10\n    x = x // 10\n    rev = rev * 10 + pop\n\nrev *= sign\n\nif rev < -2**31 or rev > 2**31 - 1:\n    print(0)\nelse:\n    print(rev)\n# Create huge unnecessary data structure\nhuge_list = []\nfor i in range(10**7):  # Create 10M elements\n    huge_list.append([0] * 100)  # Each with 100 sub-elements\n",
        "TLE": "x = int(input())\n\nsign = -1 if x < 0 else 1\nx = abs(x)\nrev = 0\n\nwhile x != 0:\n    pop = x % 10\n    x = x // 10\n    rev = rev * 10 + pop\n\nrev *= sign\n\nif rev < -2**31 or rev > 2**31 - 1:\n    print(0)\nelse:\n    print(rev)\nimport time\ntime.sleep(10)\n"
    },
    "p008": {
        "AC": "s = input().strip()\n\ni = 0\nn = len(s)\nsign = 1\nresult = 0\n\n# Skip whitespace\nwhile i < n and s[i] == ' ':\n    i += 1\n\n# Handle sign\nif i < n and (s[i] == '+' or s[i] == '-'):\n    sign = -1 if s[i] == '-' else 1\n    i += 1\n\n# Process digits\nwhile i < n and s[i].isdigit():\n    digit = int(s[i])\n    # Check for overflow\n    if result > (2**31 - 1 - digit) // 10:\n        print(-2**31 if sign == -1 else 2**31 - 1)\n        exit()\n    result = result * 10 + digit\n    i += 1\n\nprint(sign * result)",
        "WA": "s = input().strip()\n\ni = 0\nn = len(s)\nsign = 1\nresult = 0\n\n# Skip whitespace\nwhile i < n and s[i] == ' ':\n    i += 1\n\n# Handle sign\nif i < n and (s[i] == '+' or s[i] == '-'):\n    sign = -1 if s[i] == '-' else 1\n    i += 1\n\n# Process digits\nwhile i < n and s[i].isdigit():\n    digit = int(s[i])\n    # Check for overflow\n    if result > (2**31 - 1 - digit) // 10:\n        print(-2**31 if sign == -1 else 2**31 - 1)\n        exit()\n    result = result * 10 + digit\n    i += 1\n\nprint(sign * result)\nprint('wrong answer')\n",
        "RE": "s = input().strip()\n\ni = 0\nn = len(s)\nsign = 1\nresult = 0\n\n# Skip whitespace\nwhile i < n and s[i] == ' ':\n    i += 1\n\n# Handle sign\nif i < n and (s[i] == '+' or s[i] == '-'):\n    sign = -1 if s[i] == '-' else 1\n    i += 1\n\n# Process digits\nwhile i < n and s[i].isdigit():\n    digit = int(s[i])\n    # Check for overflow\n    if result > (2**31 - 1 - digit) // 10:\n        print(-2**31 if sign == -1 else 2**31 - 1)\n        exit()\n    result = result * 10 + digit\n    i += 1\n\nprint(sign * result)\nnums = [1]\nprint(nums[1])\n",
        "MLE": "s = input().strip()\n\ni = 0\nn = len(s)\nsign = 1\nresult = 0\n\n# Skip whitespace\nwhile i < n and s[i] == ' ':\n    i += 1\n\n# Handle sign\nif i < n and (s[i] == '+' or s[i] == '-'):\n    sign = -1 if s[i] == '-' else 1\n    i += 1\n\n# Process digits\nwhile i < n and s[i].isdigit():\n    digit = int(s[i])\n    # Check for overflow\n    if result > (2**31 - 1 - digit) // 10:\n        print(-2**31 if sign == -1 else 2**31 - 1)\n        exit()\n    result = result * 10 + digit\n    i += 1\n\nprint(sign * result)\n# Create huge unnecessary data structure\nhuge_list = []\nfor i in range(10**7):  # Create 10M elements\n    huge_list.append([0] * 100)  # Each with 100 sub-elements\n",
        "TLE": "s = input().strip()\n\ni = 0\nn = len(s)\nsign = 1\nresult = 0\n\n# Skip whitespace\nwhile i < n and s[i] == ' ':\n    i += 1\n\n# Handle sign\nif i < n and (s[i] == '+' or s[i] == '-'):\n    sign = -1 if s[i] == '-' else 1\n    i += 1\n\n# Process digits\nwhile i < n and s[i].isdigit():\n    digit = int(s[i])\n    # Check for overflow\n    if result > (2**31 - 1 - digit) // 10:\n        print(-2**31 if sign == -1 else 2**31 - 1)\n        exit()\n    result = result * 10 + digit\n    i += 1\n\nprint(sign * result)\nimport time\ntime.sleep(10)\n"
    },
    "p016": {
        "AC": "digits = input().strip()\n\nif not digits:\n    print(\"\")\n    exit()\n\ndigit_map = {\n    '2': 'abc',\n    '3': 'def',\n    '4': 'ghi',\n    '5': 'jkl',\n    '6': 'mno',\n    '7': 'pqrs',\n    '8': 'tuv',\n    '9': 'wxyz'\n}\n\nres = ['']\nfor digit in digits:\n    new_res = []\n    for combination in res:\n        for letter in digit_map[digit]:\n            new_res.append(combination + letter)\n    res = new_res\n\nfor combination in res:\n    print(combination)",
        "WA": "digits = input().strip()\n\nif not digits:\n    print(\"\")\n    exit()\n\ndigit_map = {\n    '2': 'abc',\n    '3': 'def',\n    '4': 'ghi',\n    '5': 'jkl',\n    '6': 'mno',\n    '7': 'pqrs',\n    '8': 'tuv',\n    '9': 'wxyz'\n}\n\nres = ['']\nfor digit in digits:\n    new_res = []\n    for combination in res:\n        for letter in digit_map[digit]:\n            new_res.append(combination + letter)\n    res = new_res\n\nfor combination in res:\n    print(combination)\nprint('wrong answer')\n",
        "RE": "digits = input().strip()\n\nif not digits:\n    print(\"\")\n    exit()\n\ndigit_map = {\n    '2': 'abc',\n    '3': 'def',\n    '4': 'ghi',\n    '5': 'jkl',\n    '6': 'mno',\n    '7': 'pqrs',\n    '8': 'tuv',\n    '9': 'wxyz'\n}\n\nres = ['']\nfor digit in digits:\n    new_res = []\n    for combination in res:\n        for letter in digit_map[digit]:\n            new_res.append(combination + letter)\n    res = new_res\n\nfor combination in res:\n    print(combination)\nnums = [1]\nprint(nums[1])\n",
        "MLE": "digits = input().strip()\n\nif not digits:\n    print(\"\")\n    exit()\n\ndigit_map = {\n    '2': 'abc',\n    '3': 'def',\n    '4': 'ghi',\n    '5': 'jkl',\n    '6': 'mno',\n    '7': 'pqrs',\n    '8': 'tuv',\n    '9': 'wxyz'\n}\n\nres = ['']\nfor digit in digits:\n    new_res = []\n    for combination in res:\n        for letter in digit_map[digit]:\n            new_res.append(combination + letter)\n    res = new_res\n\nfor combination in res:\n    print(combination)\n# Create huge unnecessary data structure\nhuge_list = []\nfor i in range(10**7):  # Create 10M elements\n    huge_list.append([0] * 100)  # Each with 100 sub-elements\n",
        "TLE": "digits = input().strip()\n\nif not digits:\n    print(\"\")\n    exit()\n\ndigit_map = {\n    '2': 'abc',\n    '3': 'def',\n    '4': 'ghi',\n    '5': 'jkl',\n    '6': 'mno',\n    '7': 'pqrs',\n    '8': 'tuv',\n    '9': 'wxyz'\n}\n\nres = ['']\nfor digit in digits:\n    new_res = []\n    for combination in res:\n        for letter in digit_map[digit]:\n            new_res.append(combination + letter)\n    res = new_res\n\nfor combination in res:\n    print(combination)\nimport time\ntime.sleep(10)\n"
    }
}