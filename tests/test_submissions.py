import unittest
import requests
import asyncio
from redis import asyncio as aioredis
from pydantic import ValidationError
import helper
from user_test_functions import User
from test_models.submission_schemas import GetSubmissionModel, SubmissionList, SubmissionLog

ADMIN = User('admin', 'admin')
ADMIN_ID = 1
TEST_USER_1 = User('test_user_1', 'test_user_1')
TEST_USER_1_ID = 2
TEST_USER_2 = User('test_user_2', 'test_user_2')
TEST_USER_2_ID = 3
TEST_USER_3 = User('test_user_3', 'test_user_3')
TEST_USER_3_ID = 4
TEST_USER_4 = User('test_user_4', 'test_user_4')
TEST_USER_4_ID = 5
TEST_USER_5 = User('test_user_5', 'test_user_5')
TEST_USER_5_ID = 6
REDIS_URL = 'redis://localhost:6379/0'

# all solutions are generated by claude
PYTHON_AC_001 = """
n = int(input())
nums = list(map(int, input().split()))
target = int(input())

num_map = {}
for i, num in enumerate(nums):
    complement = target - num
    if complement in num_map:
        print(num_map[complement], i)
        break
    num_map[num] = i
"""
PYTHON_WA_001 = """
n = int(input())
nums = list(map(int, input().split()))
target = int(input())

# Wrong logic - always returns first two indices
for i in range(n):
    for j in range(i + 1, n):
        if nums[i] + nums[j] == target:
            print(i + 1, j + 1)  # Wrong: 1-indexed instead of 0-indexed
            break
    else:
        continue
    break
"""
PYTHON_RE_001 = """
n = int(input())
nums = list(map(int, input().split()))
target = int(input())

# Will cause index error when no solution exists
for i in range(n):
    for j in range(i + 1, n):
        if nums[i] + nums[j] == target:
            print(i, j)
            # if there is a solution, trigger RE
            print(nums[n], nums[n + 1])
            exit()

# This will cause an error if we reach here
print(nums[n], nums[n + 1])  # Index out of bounds
"""
PYTHON_TLE_001 = """
import time

n = int(input())
nums = list(map(int, input().split()))
target = int(input())

# Intentional delay to cause TLE
time.sleep(2)

num_map = {}
for i, num in enumerate(nums):
    complement = target - num
    if complement in num_map:
        print(num_map[complement], i)
        break
    num_map[num] = i
"""
PYTHON_MLE_001 = """
n = int(input())
nums = list(map(int, input().split()))
target = int(input())

# Create huge unnecessary data structure
huge_list = []
for i in range(10**7):  # Create 10M elements
    huge_list.append([0] * 100)  # Each with 100 sub-elements

num_map = {}
for i, num in enumerate(nums):
    complement = target - num
    if complement in num_map:
        print(num_map[complement], i)
        break
    num_map[num] = i
"""
CPP_AC_001 = """
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

int main() {
    int n;
    cin >> n;
    
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    int target;
    cin >> target;
    
    unordered_map<int, int> numMap;
    for (int i = 0; i < n; i++) {
        int complement = target - nums[i];
        if (numMap.find(complement) != numMap.end()) {
            cout << numMap[complement] << " " << i << endl;
            return 0;
        }
        numMap[nums[i]] = i;
    }
    
    return 0;
}
"""
CPP_WA_001 = """
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n;
    cin >> n;
    
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    int target;
    cin >> target;
    
    // Wrong: returns 1-indexed instead of 0-indexed
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (nums[i] + nums[j] == target) {
                cout << i + 1 << " " << j + 1 << endl;  // Wrong indexing
                return 0;
            }
        }
    }
    
    return 0;
}
"""
CPP_RE_001 = """
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n;
    cin >> n;
    
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    int target;
    cin >> target;
    
    // Will cause segmentation fault
    int* ptr = nullptr;
    *ptr = 42;  // Dereferencing null pointer
    
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (nums[i] + nums[j] == target) {
                cout << i << " " << j << endl;
                return 0;
            }
        }
    }
    
    return 0;
}
"""
CPP_CE_001 = """
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

int main() {
    int n;
    cin >> n;
    
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    int target;
    cin >> target;
    
    unordered_map<int, int> numMap;
    for (int i = 0; i < n; i++) {
        int complement = target - nums[i];
        if (numMap.find(complement) != numMap.end()) {
            cout << numMap[complement] << " " << i << endl;
            return 0;
        }
        numMap[nums[i]] = i;
    // Missing closing brace for for loop - compilation error
    
    return 0;
}
"""
CPP_TLE_001 = """
#include <iostream>
#include <vector>
#include <unordered_map>
#include <chrono>
#include <thread>
using namespace std;

int main() {
    int n;
    cin >> n;
    
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    int target;
    cin >> target;
    
    // Intentional delay to cause TLE
    this_thread::sleep_for(chrono::seconds(2));
    
    unordered_map<int, int> numMap;
    for (int i = 0; i < n; i++) {
        int complement = target - nums[i];
        if (numMap.find(complement) != numMap.end()) {
            cout << numMap[complement] << " " << i << endl;
            return 0;
        }
        numMap[nums[i]] = i;
    }
    
    return 0;
}
"""
CPP_MLE_001 = """
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

int main() {
    int n;
    cin >> n;
    
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    int target;
    cin >> target;
    
    // Allocate huge amount of memory to cause MLE
    vector<vector<int>> huge_memory;
    for (int i = 0; i < 10000000; i++) {
        huge_memory.push_back(vector<int>(100, 0));
    }
    
    unordered_map<int, int> numMap;
    for (int i = 0; i < n; i++) {
        int complement = target - nums[i];
        if (numMap.find(complement) != numMap.end()) {
            cout << numMap[complement] << " " << i << endl;
            return 0;
        }
        numMap[nums[i]] = i;
    }
    
    return 0;
}
"""

class TestSubmissionEndpoints(unittest.IsolatedAsyncioTestCase):

    """this class test all submission endpoints"""

    @classmethod
    def setUpClass(cls) -> None:
        
        """init a list for the submissions and submit some codes"""

        cls.submissions = []
        TEST_USER_2.login()
        response = TEST_USER_2.submit_code('p001', 'python', PYTHON_AC_001)
        cls.submissions.append(
            {
                'submission_id': response.json()['data']['submission_id'],
                'user_id': TEST_USER_2_ID,
                'correct_result': 'AC',
            }
        )
        TEST_USER_2.logout()

    async def asyncSetUp(self) -> None:
        
        """connect the redis and clear the cache"""

        self.redis = aioredis.from_url(REDIS_URL)
        await helper.clear_api_cache(self.redis)

    async def asyncTearDown(self) -> None:
        
        """disconnect from the redis"""

        if hasattr(self, 'redis'):
            await self.redis.close()
            await self.redis.connection_pool.disconnect() # pyright: ignore[reportGeneralTypeIssues]

    def test_a_submit_code(self):

        """test the submit code endpoint"""

        # not logged in -> unauthorized
        response = TEST_USER_1.submit_code('', 'python', PYTHON_RE_001)
        self.assertEqual(response.status_code, requests.codes.unauthorized)

        # wrong format -> bad request
        TEST_USER_1.login()
        response = TEST_USER_1.submit_code('', 'python', PYTHON_RE_001)
        self.assertEqual(response.status_code, requests.codes.bad_request)

        # no such problem -> not found
        response = TEST_USER_1.submit_code('p050', 'python', PYTHON_RE_001)
        self.assertEqual(response.status_code, requests.codes.not_found)

        # language is not supported -> not found
        response = TEST_USER_1.submit_code('p001', 'rust', 'some code')
        self.assertEqual(response.status_code, requests.codes.not_found)

        # correct format -> ok, pending
        response = TEST_USER_1.submit_code('p001', 'python', PYTHON_RE_001)
        self.assertEqual(response.status_code, requests.codes.ok)
        self.assertEqual(response.json()['data']['status'], 'pending')
        self.submissions.append(
            {
                'submission_id': response.json()['data']['submission_id'],
                'user_id': TEST_USER_1_ID,
                'correct_result': 'RE',
            }
        )

        # four submissions in a minute -> too many requests
        response = TEST_USER_1.submit_code('p001', 'python', PYTHON_TLE_001)
        self.submissions.append(
            {
                'submission_id': response.json()['data']['submission_id'],
                'user_id': TEST_USER_1_ID,
                'correct_result': 'TLE',
            }
        )
        response = TEST_USER_1.submit_code('p001', 'python', PYTHON_AC_001)
        self.submissions.append(
            {
                'submission_id': response.json()['data']['submission_id'],
                'user_id': TEST_USER_1_ID,
                'correct_result': 'AC',
            }
        )
        response = TEST_USER_1.submit_code('p001', 'python', PYTHON_MLE_001)
        self.assertEqual(response.status_code, requests.codes.too_many_requests)

        TEST_USER_1.logout()

    def test_b_get_submission(self):

        """tes the get submission endpoint"""

        # get a submission of test_user_2
        target_submission_id = None
        for submission in self.submissions:
            if submission['user_id'] == TEST_USER_2_ID:
                target_submission_id = submission['submission_id']
                break
        assert target_submission_id is not None

        # not logged in -> unauthorized
        response = TEST_USER_1.get_submission('no_such_id')
        self.assertEqual(response.status_code, requests.codes.unauthorized)

        # no submissions with the id -> not found
        TEST_USER_1.login()
        response = TEST_USER_1.get_submission('no_such_id')
        self.assertEqual(response.status_code, requests.codes.not_found)

        # not self's submission & not an admin -> forbidden
        response = TEST_USER_1.get_submission(target_submission_id)
        self.assertEqual(response.status_code, requests.codes.forbidden)

        # self's submission -> ok
        TEST_USER_2.login()
        response = TEST_USER_2.get_submission(target_submission_id)
        self.assertEqual(response.status_code, requests.codes.ok)
        response_data = response.json()['data']
        try:
            parsed_response = GetSubmissionModel(**response_data)
        except ValidationError:
            self.fail('the get submission response format is incorrect')

        # admin check -> ok
        ADMIN.login()
        response = ADMIN.get_submission(target_submission_id)
        self.assertEqual(response.status_code, requests.codes.ok)
        response_data = response.json()['data']
        try:
            parsed_response = GetSubmissionModel(**response_data)
        except ValidationError:
            self.fail('the get submission response format is incorrect')

        ADMIN.logout()
        TEST_USER_1.logout()
        TEST_USER_2.logout()

    async def test_c_get_submission_list(self):

        """test the get submission list endpoint"""

        # post more submissions
        TEST_USER_3.login()
        TEST_USER_4.login()
        TEST_USER_5.login()
        response = TEST_USER_3.submit_code('p001', 'python', PYTHON_WA_001)
        self.submissions.append(
            {
                'submission_id': response.json()['data']['submission_id'],
                'user_id': TEST_USER_3_ID,
                'correct_result': 'WA',
            }
        )
        response = TEST_USER_3.submit_code('p001', 'python', PYTHON_MLE_001)
        self.submissions.append(
            {
                'submission_id': response.json()['data']['submission_id'],
                'user_id': TEST_USER_3_ID,
                'correct_result': 'MLE',
            }
        )
        response = TEST_USER_4.submit_code('p001', 'cpp', CPP_CE_001)
        self.submissions.append(
            {
                'submission_id': response.json()['data']['submission_id'],
                'user_id': TEST_USER_4_ID,
                'correct_result': 'CE',
            }
        )
        response = TEST_USER_4.submit_code('p001', 'cpp', CPP_MLE_001)
        self.submissions.append(
            {
                'submission_id': response.json()['data']['submission_id'],
                'user_id': TEST_USER_4_ID,
                'correct_result': 'MLE',
            }
        )
        response = TEST_USER_4.submit_code('p001', 'cpp', CPP_RE_001)
        self.submissions.append(
            {
                'submission_id': response.json()['data']['submission_id'],
                'user_id': TEST_USER_4_ID,
                'correct_result': 'RE',
            }
        )
        response = TEST_USER_5.submit_code('p001', 'cpp', CPP_TLE_001)
        self.submissions.append(
            {
                'submission_id': response.json()['data']['submission_id'],
                'user_id': TEST_USER_5_ID,
                'correct_result': 'TLE',
            }
        )
        response = TEST_USER_5.submit_code('p001', 'cpp', CPP_WA_001)
        self.submissions.append(
            {
                'submission_id': response.json()['data']['submission_id'],
                'user_id': TEST_USER_5_ID,
                'correct_result': 'WA',
            }
        )
        response = TEST_USER_5.submit_code('p001', 'cpp', CPP_AC_001)
        self.submissions.append(
            {
                'submission_id': response.json()['data']['submission_id'],
                'user_id': TEST_USER_5_ID,
                'correct_result': 'AC',
            }
        )
        await asyncio.sleep(10)

        # not logged in -> unauthorized
        response = TEST_USER_1.get_submission_list(status='success')
        self.assertEqual(response.status_code, requests.codes.unauthorized)

        # no user_id params for a normal user -> forbidden
        TEST_USER_1.login()
        response = TEST_USER_1.get_submission_list(status='success')
        self.assertEqual(response.status_code, requests.codes.forbidden)

        # the page_size is incorrect -> bad request
        response = TEST_USER_1.get_submission_list(
            user_id=TEST_USER_1_ID,
            page=1,
            page_size=5,
        )
        self.assertEqual(response.status_code, requests.codes.bad_request)

        # page num too large -> not found
        response = TEST_USER_1.get_submission_list(
            user_id=TEST_USER_1_ID,
            page=50,
            page_size=20,
        )
        self.assertEqual(response.status_code, requests.codes.not_found)

        # success -> ok
        response = TEST_USER_1.get_submission_list(
            user_id=TEST_USER_1_ID,
            page=1,
            page_size=20,
        )
        self.assertEqual(response.status_code, requests.codes.ok)
        response_data = response.json()['data']
        try:
            parsed_response = SubmissionList(**response_data)
        except ValidationError:
            self.fail('the format of the submission list is incorrect')

        # check for the corresponding cache
        related_keys = await helper.get_api_cache_keys(
            redis=self.redis,
            format=f'fastapi-cache:submission_list:{TEST_USER_1_ID}:*'
        )
        self.assertNotEqual(related_keys, [], 'cache of submission list failed')

        # both user_id and problem_id is None -> bad request
        ADMIN.login()
        response = ADMIN.get_submission_list(status='success')
        self.assertEqual(response.status_code, requests.codes.bad_request)

        # success -> ok
        response = ADMIN.get_submission_list(
            problem_id='p001',
            page=1,
            page_size=20,
        )
        self.assertEqual(response.status_code, requests.codes.ok)
        response_data = response.json()['data']
        try:
            parsed_response = SubmissionList(**response_data)
        except ValidationError:
            self.fail('the format of the submission list is incorrect')

        # check for the corresponding cache
        related_keys = await helper.get_api_cache_keys(
            redis=self.redis,
            format='fastapi-cache:submission_list:*:p001:*',
        )
        self.assertNotEqual(related_keys, [], 'cache of submission list failed')

        # find a submission of test_user_1, rejudge it, check if 
        # the cache can be deleted normally
        target_submission = None
        for submission in self.submissions:
            if submission['user_id'] == TEST_USER_1_ID:
                target_submission = submission
        assert target_submission is not None

        ADMIN.rejudge_code(target_submission['submission_id'])
        related_keys = await helper.get_api_cache_keys(
            redis=self.redis,
            format=f'fastapi-cache:submission_list:{TEST_USER_1_ID}:*'
        )
        self.assertEqual(related_keys, [], 'cache of submission list deletion failed')
        related_keys = await helper.get_api_cache_keys(
            redis=self.redis,
            format='fastapi-cache:submission_list:*:p001:*'
        )
        self.assertEqual(related_keys, [], 'cache of submission list deletion failed')

        ADMIN.logout()
        TEST_USER_1.logout()
        TEST_USER_3.logout()
        TEST_USER_4.logout()
        TEST_USER_5.logout()

    def test_d_rejudge_code(self):

        """test the rejudge endpoint"""

        submission_id = self.submissions[0]['submission_id']

        # not logged in -> unauthorized
        response = TEST_USER_1.rejudge_code(submission_id)
        self.assertEqual(response.status_code, requests.codes.unauthorized)

        # not an admin -> forbidden
        TEST_USER_1.login()
        response = TEST_USER_1.rejudge_code(submission_id)
        self.assertEqual(response.status_code, requests.codes.forbidden)

        # success -> ok
        ADMIN.login()
        response = ADMIN.rejudge_code(submission_id)
        self.assertEqual(response.status_code, requests.codes.ok)
        self.assertEqual(response.json()['data']['status'], 'pending')

        TEST_USER_1.logout()
        ADMIN.logout()

    def test_e_submission_log(self):

        """test the submission log endpoint"""

        # get a submission of test_user_1
        submission_id = None
        for submission in self.submissions:
            if submission['user_id'] == TEST_USER_1_ID:
                submission_id = submission['submission_id']
        assert submission_id is not None

        # not logged in -> unauthorized
        response = TEST_USER_2.get_submission_detail(submission_id)
        self.assertEqual(response.status_code, requests.codes.unauthorized)

        # cannot find the submission -> not found
        TEST_USER_2.login()
        response = TEST_USER_2.get_submission_detail('no_such_id')
        self.assertEqual(response.status_code, requests.codes.not_found)

        # not self's submission -> forbidden
        response = TEST_USER_2.get_submission_detail(submission_id)
        self.assertEqual(response.status_code, requests.codes.forbidden)

        # success -> ok
        TEST_USER_1.login()
        response = TEST_USER_1.get_submission_detail(submission_id)
        self.assertEqual(response.status_code, requests.codes.ok)
        response_data = response.json()['data']
        try:
            parsed_response = SubmissionLog(**response_data)
        except ValidationError:
            self.fail('the format of the submission log is incorrect')

        # admin check -> success -> ok
        ADMIN.login()
        response = ADMIN.get_submission_detail(submission_id)
        self.assertEqual(response.status_code, requests.codes.ok)
        response_data = response.json()['data']
        try:
            parsed_response = SubmissionLog(**response_data)
        except ValidationError:
            self.fail('the format of the submission log is incorrect')

        ADMIN.logout()
        TEST_USER_1.logout()
        TEST_USER_2.logout()

    def test_f_judge(self):

        """test the result of the judge"""

        ADMIN.login()
        for submission in self.submissions:
            response = ADMIN.get_submission_detail(submission['submission_id'])
            test_cases = response.json()['data']['details']
            for case in test_cases:
                self.assertEqual(
                    case['result'],
                    submission['correct_result'],
                    f"AssertionError '{case['result']} != '{submission['correct_result']}, submission_id: {submission['submission_id']}"
                )

if __name__ == "__main__":
    unittest.main()
